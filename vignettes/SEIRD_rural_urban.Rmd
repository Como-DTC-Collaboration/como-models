---
title: "Urban and rural metapopulations model"
author: "Solveig A. van der Vegt"
output: rmarkdown::html_vignette
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{The SEIRD model with urban and rural communities}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction
Here we consider an extension to the basic SEIRD model that considers multiple interacting communities. For simplicity, we consider only two interacting communities here. Each community consists of a susceptible, exposed, infectious and recovered population. Although one can consider two generic communities, in this implementation we consider specifically one urban and one rural community and use data from the WHO and UN to specify contacts in each community. In the following sections, we will explain the equations of the model, the implementation in this package and how to use it, and discuss briefly how the connectedness level between communities affects the results.

## The mathematical model
### The equations
We base our model of connected communities on the model presented by Tun et al. [-@Tun21]. We designate the urban community $U$ and the rural community $Y$. Following the same naming pattern for variables and parameters as used for the basic SEIRD model, the ordinary differential equations describing how the populations evolve are as follows, where variable $X_Z$ (for $X \in \{S,E,I,R\}, Z \in \{U, Y\}$) designates the population of individuals with infectedness status $X$ in community $Z$,

\begin{equation}
\begin{split}
    \frac{\text{d}S_U}{\text{d}t} = &-\beta S_U \left((I_U+I_Y) (\phi_U N_U + \phi_Y N_Y) C + \frac{I_U}{\phi_U}N_U(1-C)\right),\\
    \frac{\text{d}S_Y}{\text{d}t} = &-\beta S_Y \left((I_U+I_Y) (\phi_U N_U + \phi_Y N_Y) C + \frac{I_Y}{\phi_Y}N_Y(1-C)\right),\\
    \frac{\text{d}E_U}{\text{d}t} = &  \beta S_U \left((I_U+I_Y) (\phi_U N_U + \phi_Y N_Y) C + \frac{I_U}{\phi_U}N_U(1-C)\right) - \kappa E_U,\\
    \frac{\text{d}E_Y}{\text{d}t} = & \beta S_Y \left((I_U+I_Y) (\phi_U N_U + \phi_Y N_Y) C + \frac{I_Y}{\phi_Y}N_Y(1-C)\right)  - \kappa E_Y,\\
    \frac{\text{d}I_U}{\text{d}t} = & \kappa E_U - (\gamma + \mu)I_U ,\\
    \frac{\text{d}I_Y}{\text{d}t} = & \kappa E_Y - (\gamma + \mu)I_Y,\\
    \frac{\text{d}R_U}{\text{d}t} = & \gamma I_U,\\
    \frac{\text{d}R_Y}{\text{d}t} = & \gamma I_Y,\\
    \frac{\text{d}D_U}{\text{d}t} = & \mu I_U,\\
    \frac{\text{d}D_Y}{\text{d}t} = & \mu I_Y.\\
\end{split}
\end{equation}

\noindent In the above equations, $\phi_U$ is the fraction of the population that lives in an urban environment, $\phi_Y$ is the fraction of the population that lives in a rural environment, $N_U$ is the average number of contacts that an urban individual has in a day, and $N_Y$ is the average number of contacts that a rural individual has in a day, so $(\phi_U N_U + \phi_Y N_Y)$ is the average number of contacts for any individual. $C$ is the connectedness parameter, where $C=1$ means the communities are well-mixed with each other, and $C=0$ means the two communities do not interact at all.

The difference between this model and the basic SEIRD model is the computation of the number of infectious contacts that a susceptible individual has. This is reflected in the equations for $S_Z$ and $E_Z$. Individuals in either community can either come into contact with people from their own community or from the other community. The extent to which the latter happens is determined by the connectedness parameter $C$. If the communities are completely separate, i.e. $C=0$, the probability that a susceptible individual in community $Z$ interacts with an infectious individual is the number of contacts that someone in that community has, $N_Z$, multiplied by the probability that a contact is infectious, $I_Z/\phi_Z$. If the communities are well-mixed with each other, the probability is again the number of contacts multiplied by the probability that a contact is infectious, although now the number of contacts that an individual has is averaged over the communities, so $\phi_U N_U + \phi_Y N_Y$, and the individual can encounter people from either community so the probability of an infectious contact is $I_U+I_Y$. The extent to which the communities are connected, designated by $C$, determines to which extent the two extreme contact patterns play a role, and thus we obtain the weighted average that appears in the equations above which designates the total probability of a susceptible individual in $Z$ having an infectious contact: $(I_U+I_Y) (\phi_U N_U + \phi_Y N_Y) C + \frac{I_Z}{\phi_Z}N_Z(1-C)$.

### The contact parameters $N_Z$
The average number of contacts for an individual in a given community $Z$, $N_Z$, is computed based on the country-specific contact matrices [@Prem20], age demographics [@UN], and urban/rural populations split [@WB]. For a detailed discussion of the contact matrices, see the age-structured model. The number of contacts in community $Z$ of a specific country is computed by first adding up all the contacts in the contact matrix for each age group so we obtain the total number of contacts that an individual in a specific age group has in a day. We obtain the vector with population by age for community $Z$ by taking the age demographic data for the whole country and multiplying it by the fraction of the population that lives in community $Z$. We then take a weighted average over the age groups, using the age demographic data as weights. Lastly, we divide the number of contacts by the total population size to normalize the number of contacts (all populations in the model are normalized). We thus get
\begin{equation}
    N_{Z} = \frac{ \sum_{m = 1}^K c_Z(n,m)\cdot y_Z}{\text{total population}}, 
\end{equation}
where $c_Z(n,m)$ is the entry in contact matrix $c$ for community $Z$ denoting the number of contacts someone in age group $n$ has with individuals in age group $m$, and $y_Z$ is the vector designating the number of individuals in each age group in community $Z$.

## Implementation and use
In this section, we walk through how to use the model. First, we will show how to load and prep the appropriate data, which is included in the package. We'll then walk through an example simulation. In the last subsection, we'll briefly discuss the effect of varying the connectedness parameter $C$.

### Loading and prepping country-specific data
First, we load the contact matrices for the urban and rural communities. Because the two sets of contact matrices don't cover the exact same countries, we also make a list of countries for which we have both contact matrices, which we can use later to check if the choice of country is valid.
```{r}
library(comomodels)
library(tidyverse)
library(glue)
library(deSolve)
library(reshape2)
library(gridExtra)
library(viridis)

# load contact matrices
load("../data/contact_all_urban.rda") # ROWS are age of person, COLUMNS are age of contact
names_urban <- names(contact_all_urban)
load("../data/contact_all_rural.rda")
names_rural <- names(contact_all_rural)
names_common <- intersect(names_urban,names_rural)
```
We also load in all demographic data, and load in a list showing the three-letter code for each country.
```{r}
#import all demographic data
# data on percentage of the population that is rural
load("../data/percentrural_by_country.rda")
# age demographic breakdown into 5 year age categories
load("../data/agedemographics_by_country.rda")
# conversion table from 3 letter country codes to full names
load("../data/country_codetoname.rda")
```

Next, we select a country, in this case Tunisia. This needs to happen with a three letter code. We check if the country is valid choice by checking if it appears in the list of countries for which we have both a rural and urban contact matrix.
```{r}
# specify country
country <- "TUN"
if (!(country %in% names_common)) {
  stop(paste(country," is not a valid three-letter country code."))
}
```

Now that we have specified a country, we extract from the data what percentage of its population is rural. Because the most recent year that all our data source have in common is 2019, we select all our data from that year.
```{r}
# get fraction of population that is rural
country_rural <- percentrural_by_country$`2019`[percentrural_by_country$`Country Code` == country]
frac_rural <- country_rural/100 #turn percentage into fraction
```

The last step in our data prep is to create the vector of normalized population per age group for the specific country. The contact matrices have 5-year age groups with the oldest group being 80+. Because the age demographics go up to 100+, we need to sum the last five age groups in the demographics vector to ensure compatibility with the contact matrices.

```{r}
# get fraction of population in each 5-year age range
# get full name of country
country_fullname <- country_codetoname$CountryName[country_codetoname$CountryCode == country]
# extract age demographic vector
pop_byage_2019 <- agedemographics_by_country[(agedemographics_by_country$`Region, subregion, country or area *` == country_fullname
                                     & agedemographics_by_country$`Reference date (as of 1 July)` == 2019),5:25]
pop_byage_2019 <- as.double(pop_byage_2019)
# normalize to fractions of the total population
pop_byage_2019 <- pop_byage_2019/sum(pop_byage_2019) 
# must sum last five entries because contact matrices have an 80+ category instead of 100+
pop_byage_2019 <- c(pop_byage_2019[1:15], sum(pop_byage_2019[16:20]))
```

### Basic simulation
We start by creating an instance of the model class,
```{r}
model <- SEIRD_RU()
```

followed by setting the parameter values of the model that are not determined by the demographics or contact matrices. Here, we use transmission parameter values that correspond to ancestral SARS-CoV-2 (opposed to, say, the strains): for more information on these parameter values, consult the documentation for `covid_transmission_parameters`.

```{r}
parameters <- covid_transmission_parameters() # base variant
print(parameters)

kappa <- parameters$kappa
gamma <- parameters$gamma
mu <- parameters$mu
R0_target <- parameters$R0

C <- 1 # connectedness parameter
```
Setting the value of $\beta$ in this model is a bit more complex, so we will come back to that in a little bit.

Next we set the initial conditions of the model, where we specify separately what fraction of the population is infected in the urban community and what fraction is infected in the rural community: here, we start with infection solely in the urban community. Note, here that these are fractions of the total population across both communities. Because the populations are normalized, all initial conditions together must sum to one. In this example, we seed the epidemic in the urban community.

```{r}
start_infected_urban <- 0.0001
start_infected_rural <- 0
S0U <- 1 - frac_rural - start_infected_urban
E0U <- 0
I0U <- start_infected_urban
R0U <- 0
S0Y <- frac_rural - start_infected_rural
E0Y <- 0
I0Y <- start_infected_rural
R0Y <- 0
initial_conditions(model) <- list(S0U, E0U, I0U, R0U,
                                  S0Y, E0Y, I0Y, R0Y)
```

In this implementation of the SEIRD model with two communities, there are several options for inputting data about the age demographics of the communities and the contacts they have. You can choose to use the data sets in this package that provide this information for specific countries. Note that is you want to do this, i.e. use contact matrices and demographic data, it is essential that you set the demographic data BEFORE entering the contact matrices. This is done via the code below. The number of contacts and fraction of the population that live in a rural environment are calculated for you.

```{r}
#set demographic data
country_demog(model) <- list(pop_byage_2019 * (1 - frac_rural), pop_byage_2019 * frac_rural)

# set contact matrices
contact_rates(model) <- list(contact_all_urban[[country]],  contact_all_rural[[country]])
```

Instead of using the data sets you can also choose to set the contact rates and the fraction of the population that is rural yourself. This is done by assigning the fraction rural, a single number which between 0 and 1, directly to the model. Note that if you wish to use contact matrices, full age demographic data is required, but you are free to use age demographic data and set the contact rates manually.

As noted above, we still need to set the value of $\beta$ and to assign the parameter values to the model. In other vignettes, such as for the `SEIRD` model, we determined $\beta$ based on our target value of $R_0$. Here, a simple expression for $R_0$ cannot be derived due to the added complexity in the model. Instead, we approximate a value of $\beta$ given a value of $R_0$ by noting that for $C = 1$, this model is equivalent to the `SEIRD` model. We can thus use the $R_0$ expression for the `SEIRD` model to obtain an approximate value for $\beta$. The only thing to note here is that in the `SEIRD` model, the number of contacts that a person has is included in the value of $\beta$, whereas in this model, it is not. We thus need to divide through by the average number of contacts to obtain a value of $\beta$ for this model.

```{r}
beta_approx <- (gamma + mu) * R0_target
beta <- beta_approx / (contact_rates(model)$urban * (1 - frac_rural) + contact_rates(model)$rural * frac_rural)
transmission_parameters(model) <- list(beta, kappa, gamma, mu, C)
R0(model)
```

We can compute the basic reproduction number using the next generation matrix method explained by van den Driessche [-@vandenDriessche17]. The basic reproduction number for the model can be calculated by calling `R0(model)`, as done above. As shown, this approximation of $\beta$ gives us the target value of $R_0$.

The last thing to do is to set the time span over which to simulate the model, and then run it.

```{r}
tend <- 200
time <- seq(0, tend, by = 1)

# run simulation
output <- run(model, time)
```

The output from the model can then be plotted such that the populations are plotted separately for both communities. Here, we drop the underscore notation denoting the location for clarity.

```{r, fig.width=10, fig.height=5}
# create location variable and remove subscripts
states <- output$states %>% 
  mutate(location=if_else(str_detect(compartment, "_U"), "urban", "rural")) %>% 
  mutate(compartment=gsub("_U", "", compartment)) %>% 
  mutate(compartment=gsub("_Y", "", compartment))

# plot
states %>% 
  ggplot(aes(x=time, y=value)) +
  geom_line(aes(colour=compartment)) +
  facet_wrap(~location) +
  xlab("time (days)") +
  ylab("fraction of the population") +
  scale_color_brewer(palette = "Dark2")
```

We next plot cases for each region. Because of the connectiveness between the two populations, the epidemics are perfectly in sync.

```{r, fig.width=10, fig.height=5}
# create location variable and remove subscripts
changes <- output$changes %>% 
  mutate(location=if_else(str_detect(compartment, "_U"), "urban", "rural")) %>% 
  mutate(compartment=gsub("_U", "", compartment)) %>% 
  mutate(compartment=gsub("_Y", "", compartment))

# plot
changes %>% 
  filter(compartment=="Incidence") %>% 
  ggplot(aes(x=time, y=value)) +
  geom_line(aes(colour=location)) +
  xlab("time (days)") +
  ylab("fraction of the population") +
  scale_color_brewer(palette = "Dark2")
```

## The effect of varying $C$
The connectedness parameter $C$ indicates how connected the two communities are, i.e. how much the individuals in each are expected to interact with each other. At the extreme ends we have the communities completely connected and acting as one big community for $C=1$, and completely disconnected and acting as separate communities for $C=0$.

Here, we explore what happens for intermediate values by simulating the model for a range of values of $C$. We then plot daily cases in the urban and rural populations (coloured lines) as we vary $C$ (panels). When the two populations are unconnected, the outbreak occurs only in the urban population, where it began. As $C$ increases, a secondary outbreak occurs in the rural population. For small, but positive $C$ values, the outbreak in the rural population occurs substantially later than the one in the urban population. This is because, due to low connectivity between the populations, the seeding of the rural population is at a lower rate and the epidemic wave hence takes longer to sweep through this community. For larger $C$ values, the communities are essentially entirely connected, and the outbreaks occur in concert.

```{r , fig.width=10, fig.height=5}
C_values <- c(0, 0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1)
R0_vals <- vector(length = length(C_values))

for (i in seq_along(C_values)) {
  C <- C_values[i]
  transmission_parameters(model) <- list(beta, kappa, gamma, mu, C)
  out <- run(model, time)
  R0_vals[i] <- R0(model)
  result <- out$changes %>%
    mutate(C=C)

  if(i == 1)
    big_df <- result
  else
    big_df <- big_df %>% bind_rows(result)
}

# create compartments
big_df <- big_df %>% 
  mutate(location=if_else(str_detect(compartment, "_U"), "urban", "rural")) %>% 
  mutate(compartment=gsub("_U", "", compartment)) %>% 
  mutate(compartment=gsub("_Y", "", compartment))

# plot cases
big_df %>% 
  filter(compartment=="Incidence") %>% 
  ggplot(aes(x=time, y=value)) +
  geom_line(aes(colour=location)) +
  xlab("time (days)") +
  ylab("fraction of the population") +
  scale_color_brewer(palette = "Dark2") +
  facet_wrap(~C)
```

Below we plot the basic reproduction number as a function of $C$. This shows that the above result is not due to the impact that changes on $C$ have on $R_0$, since it only changes very modestly.

```{r , , fig.width=10, fig.height=5}
tibble(C=C_values, R_0=R0_vals) %>% 
  ggplot(aes(x=C, y=R_0)) +
  geom_line() +
  ylim(1, 3)
```

The above analysis shows that a population with low connectivity between subpopulations -- countries, regions, cities and so on -- can substantially slow the transit of infections when infections are seeded non-uniformly. This hints at the importance of travel restrictions, particularly during the early phase of epidemics when infections have not had the opportunity to spread across borders.

## The impact of a fragmented population on rates of transmission
Aside from reducing flow between subpopulations, fragmenting a population into smaller groups also slows spread for another reason: there are fewer contacts to infect. We now use a straightforward mathematical argument to illustrate this.

For simplicity, suppose that the latent period is very short, so that we can neglect it. Also suppose that we consider also a fully mixed population where everyone interacts with everyone else. Our `SEIRD` model then becomes an `SIR` model, with the infectious compartment dynamics determined by:

\begin{equation}
\frac{\text{d}I}{\text{d}t} = \beta S I - (\gamma + \mu ) I.
\end{equation}

Early on, $I$ is small, and we can ignore the rates of recovery or death, and we assume that the susceptible population is of roughly constant size $S=1$, meaning that the infected population grows exponentially:

\begin{equation}
I^{\text{mixed}}(t) = I(0) \exp(\beta t).
\end{equation}

Instead, now we take the above population and divide it up into two subpopulations of equal size and assume that each has half the starting number of infected individuals. Assume that each of these communities are epidemic islands and are isolated from one another. Then, the early growth rate of the epidemic in each will also be exponential, albeit with half the rate parameters:

\begin{equation}
I_j(t) = I(0)/2 \exp(\beta t/2),
\end{equation}

where $j\in (1, 2)$ indicates a subcommunity. If we calculate aggregate growth across both communities, we obtain:

\begin{equation}
I^{\text{both}}(t) = I(0) \exp(\beta t/2).
\end{equation}

Comparing $I^{\text{both}}$ with $I^{\text{mixed}}$ above, the rate of growth of the infected population is exponentially faster in the fully mixed population:

\begin{equation}
\frac{I^{\text{mixed}}(t)}{I^{\text{both}}(t)} = \exp(\beta t/2).
\end{equation}

In other words, fragmenting a population into isolated communities leads to an exponential decline in the rate of spread, even if all those communities receive a uniform initial seeding on infection which aggregates to the total in an unfragmented population. And increasing the number of subcommunities leads to an exponential decline in the rate of spread.

Interactions between subpopulations tend to reduce the impact of fragmentation, although the way in which they interact matters: if members of one community tend to commute on a daily basis to work in another community, this will result in different transmission dynamics than for people who spend half the year fully mixed with the other community and half the year entirely separate (e.g. farming communities who migrate into cities to sell their produce). For larger 
regions with more communities, the interactions between communities may be best considered as a network metapopulation model, where the patchwork of interactions are captured by a network graph: see @wang2014spatial for an introduction to such models.



## References